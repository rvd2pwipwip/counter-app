1.cd to new project folder in terminal to create new counter=app project:
create-react-app counter-app
2.cd in counter-app folder to start the app:
npm start
3.install bootstrap library in project folder:
npm i bootstrap@4.1.1
4.import bootstrap lib in index.js of project:
import "bootstrap/dist/css/bootstrap.css";
5.create new components folder inside src folder
6.create new counter.jsx component inside components directory
7.in counter.jsx, import react component and create a component class (imrc cc)
8.name the new component Counter:
import React, { Component } from 'react';
class Counter extends Component {
  state = {  }
  render() { 
    return (  );
  }
}
 
export default Counter;
9.return a simple <h1/> element wiht jsx:
render() { 
  return <h1>Hello World</h1>;
}
10.import <Counter/> component in App.js and render it in root div:
import Counter from "./components/counter";
ReactDOM.render(<Counter />, document.getElementById("root"));
11.add a button in the <Counter/> component, inside <React.Fragment/>:
return (
  <React.Fragment>
    <h1>Hello World</h1>
    <button>Increment</button>
  </React.Fragment>
);
11.in the state object of <Counter/>, create a count key with a value of 0:
state = {
  count: 0
};
12.replace <h1> with <span> and replace Hello World with dynamic value of state count:
<span>{this.state.count}</span> //{} means JS expression
13.create formatCount() method in <Counter/> that returns 'Zero' or count value:
formatCount() {
  return this.state.count === 0 ? "Zero" : this.state.count;
}
14.object destructuring of state for better DRY code:
formatCount() {
  const { count } = this.state;
  return count === 0 ? "Zero" : count;
}
15.call formatCount() inside <span/> of <Counter/> render() method:
render() {
  return (
    <React.Fragment>
      <span>{this.formatCount()}</span>
      <button>Increment</button>
    </React.Fragment>
  );
}
16.add an <img/> tag inside the <React.Fragment/> tag
17.add an imageUrl property to the Counter state object:
state = {
  count: 0,
  imageUrl: "https://picsum.photos/200"
};
18.add the state url link to the <img/> src attribute:
<React.Fragment>
  <img src={this.state.imageUrl} alt="" />
  <span>{this.formatCount()}</span>
  <button>Increment</button>
</React.Fragment>
19.delete <img/> tag and state imageUrl
20.give <span/> a className for two bootstrap classes (badge and badge-primary):
<React.Fragment>
  <span className="badge badge-primary">{this.formatCount()}</span>
  <button>Increment</button>
</React.Fragment>
21.add bootstrap m-2 class to the <span/> className to add margin:
<span className="badge badge-primary m-2">{this.formatCount()}</span>
22.add bootstrap btn btn-secondary btn-sm classes to the <button/> tag:
<button className="btn btn-secondary btn-sm">Increment</button>
23.below the <Counter/> state object, create a styles object with css attributes:
styles = {
  fontSize: 10,
  fontWeight: "bold"
};
23.add styles to the <span/> tag:
<span style={this.styles} className="badge badge-primary m-2">
  {this.formatCount()}
</span>
24.another way to add style is the inline method:
<span style={{ fontSize: 30 }} className="badge badge-primary m-2">
25.delete the styles object and the style attribute (we will only use class to define style):
<React.Fragment>
  <span className="badge badge-primary m-2">{this.formatCount()}</span>
  <button className="btn btn-secondary btn-sm">Increment</button>
</React.Fragment>
26.render class dynamically to change color of badge when value === 0
in render() method, define a const classes and set it to a string of the 2 common bootstrap classes:
const classes = "badge m-2";
27.change const classes to let classes because classes will be modified:
let classes = "badge m-2";
28.if count === 0 append badge-waring to classes, otherwise, append badge-primary:
render() {
  let classes = "badge m-2";
  classes += this.state.count === 0 ? ` badge-warning` : ` badge-primary`;
  return (
    <React.Fragment>
      <span className={classes}>{this.formatCount()}</span>
      <button className="btn btn-secondary btn-sm">Increment</button>
    </React.Fragment>
  );
}
29.for better DRY code:
let classes = "badge m-2 badge-";
classes += this.state.count === 0 ? `warning` : `primary`;
30.remove classes details from render() method with refactor shortcut (ctrl+shift+R):
getBadgeClasses() {
  let classes = "badge m-2 badge-";
  classes += this.state.count === 0 ? `warning` : `primary`;
  return classes;
}

render() {
  let classes = this.getBadgeClasses();
  return (
    <React.Fragment>
      <span className={classes}>{this.formatCount()}</span>
      <button className="btn btn-secondary btn-sm">Increment</button>
    </React.Fragment>
  );
}
31.call the getBadgeClasses() method directly in <span/> className:
render() {
  return (
    <React.Fragment>
      <span className={this.getBadgeClasses()}>{this.formatCount()}</span>
      <button className="btn btn-secondary btn-sm">Increment</button>
    </React.Fragment>
  );
}
32.add a tags array with 3 tags in it to the Counter state object:
state = {
  count: 0,
  tags: ['tag1', 'tag2', 'tag3']
};
33.render a <ul/> with a <li/> element for each element in this.state.tags:
<React.Fragment>
  <span className={this.getBadgeClasses()}>{this.formatCount()}</span>
  <button className="btn btn-secondary btn-sm">Increment</button>
  <ul>
    {this.state.tags.map(tag => (
      <li>{tag}</li>
    ))}
  </ul>
</React.Fragment>
34.assign a key to each child in map iterator (react requirement):
<li key={tag}>{tag}</li>
35.if the tags array of state is empty, render an empty state message, otherwise, render the tags:
renderTags() {
  if (this.state.tags.length === 0) return <p>No tags to render</p>;
  return (
    <ul>
      {this.state.tags.map(tag => (
        <li key={tag}>{tag}</li>
      ))}
    </ul>
  );
}

render() {
  return (
    <React.Fragment>
      {this.renderTags()}
    </React.Fragment>
  );
}

36.or do the above conditional rendering with ternary operator:
render(){
    return this.state.tags.length === 0 ? <p>No tags to render</p> : <ul>{this.state.tags.map(tag => <li key={tag}>{tag}</li>)}</ul>
  }
37.create onClick attribute of <button/> and set it to handleIncrement():
handleIncrement() {
  console.log("increment");
}
...
<button onClick={this.handleIncrement} className="btn btn-secondary btn-sm">Increment</button>
38.transform handleIncrement() into an arrow function to inherit this (else this is undefined):
handleIncrement = () => {
  console.log("increment clicked", this);
};
39.increment value of state.count when increment <button/> is clicked and update state:
handleIncrement = () => {
  this.setState({ count: this.state.count + 1 });
};
40.to pass an argument to handleIncrement(), it should be called as an arrow function inside the button's onClick:
onClick={() => this.handleIncrement(this.state.count)}
41.handleIncrement() can receive the paased argument:
handleIncrement = e => { //e is the event argment passed from the onClick arrow function
  this.setState({ count: e + 1 });
};
41.create a Counters.jsx file in the components folder and import it in index.js (replacing Counter with Counters):
import Counters from "./components/Counters";
...
ReactDOM.render(<Counters />, document.getElementById("root"));
42.create the Counters component code (imrc cc) and name the class Counters:
import React, { Component } from "react";

class Counters extends Component {
  state = {};
  render() {
    return ();
  }
}

export default Counters;
43.import Counter to render <Counter/> components in the <Counters/> component:
import React, { Component } from "react";
import Counter from "./Counter";

class Counters extends Component {
  state = {};
  render() {
    return (
      <>
        <Counter />
        <Counter />
        <Counter />
        <Counter />
      </>
    );
  }
}
44.add an array of Counter objects to the Components state to render each Counter dynamically:
state = {
  counters: []
};
45.each counter in the state counters array should have a unique id and a value:
state = {
  counters: [
    { id: 1, value: 0 },
    { id: 2, value: 1 },
    { id: 3, value: 2 },
    { id: 4, value: 3 }
  ]
};
46.render each counter from state with a map function inside the render return:
render() {
  return (
    <>
      {this.state.counters.map(c => (
        <Counter key={c.id} />
      ))}
    </>
  );
}
47.add value prop to <Counter/>:
<Counter key={c.id} value={c.value}/>
48.in Counter.jsx, initialize the state count to this.props.value:
state = {
  count: this.props.value
};
49.rename count to value (F2) everywhere:
formatCount() {
  const { value } = this.state;
  return value === 0 ? "Zero" : value;
}
50.in Counters.jsx, create a <h4/> that is a child element of <Counter/>:
<Counter key={c.id} value={c.value}>
  <h4>Title</h4>
</Counter>
51.in the render() method of Counter, console.log(this.props) to view special children props:
{value: 0, children: {â€¦}}
52.render the children element inside the return of Counter's render():
<>
  {this.props.children}
  <span className={this.getBadgeClasses()}>{this.formatCount()}</span>
  <button
    onClick={() => this.handleIncrement(this.state.value)}
    className="btn btn-secondary btn-sm"
  >
    Increment
  </button>
</>
53.in Counters.jsx, make <Counter/> children value dynamic to render the counter id:
<Counter key={c.id} value={c.value}>
  <h4>Counter #{c.id}</h4>
</Counter>
54.delete every line of code related to children...
55.add a delete button to each counter:
<button className="btn btn-danger btn-sm m-2">Delete</button>
///////////   WES BOS WAY   ///////////////
Pass down parent handleDelete to child component with props
56.the counters are stored in the <Counters/> state so the handleDelete() should be in that component:
class Counters extends Component {
  state = {
    counters: [
      { id: 1, value: 0 },
      { id: 2, value: 1 },
      { id: 3, value: 2 },
      { id: 4, value: 3 }
    ]
  };

  handleDelete = id => {
    console.log(id);
  };
  ...
57.pass the handleDelete() of <Counters/> to the props of <Counter/> so it can be used with onClick of <Counter/>:
<Counter
  key={c.id}
  value={c.value}
  id={c.id}
  handleDelete={this.handleDelete}
/>
58.in Counter.jsx, call the handleDelete that was passed through props  as an => function 
with the counter id argument:
<button
  className="btn btn-danger btn-sm m-2"
  onClick={() => {
    this.props.handleDelete(this.props.id);
  }}
>
  Delete
</button>
59.define handleDelete in Counters.jsx to delete the counter and update the <Counters/> state:
handleDelete = id => {
  // 1.copy state counters
  let counters = [...this.state.counters];
  // 2.update copy of state
  counters = this.state.counters.filter(c => c.id !== id);
  // 3.set new counters object to state
  this.setState({ counters });
};

///////////   MOSH WAY   ///////////////
Raise onDelete event to parent component

60.add a reset button to the render() of <Counters/>:
<button
  className="btn btn-primary btn-sm m-2 "
  onClick={this.handleReset}
>
  Reset
</button>
61.create the handleReset => function in <Counters/>:
handleReset = () => {
  // 1.copy state counters
  let counters = [...this.state.counters];
  console.log(counters);
  // 2.update copy of state
  counters = counters.map(c => (c.value = 0));
  console.log(counters);
  // 3.set new counters object to state
  this.setState({ counters });
};

this will not work properly because there is no single source of truth and the following code:
class Counter extends Component {
  state = {
    value: this.props.value
  };
is local to <Counter/> and is only executed once, when the component loads 
(value is not updated properly when value it is reset inside <Counters/>)
62.refactor by deleting the state property of <Counter/> 
and replace all references to this.state with this.props:
import React, { Component } from "react";
class Counter extends Component {
  formatCount() {
    const { value } = this.props;
    return value === 0 ? "Zero" : value;
  }

  getBadgeClasses() {
    let classes = "badge m-2 badge-";
    classes += this.props.value === 0 ? `warning` : `primary`;
    return classes;
  }

  render() {
    return (
      <div>
        <span className={this.getBadgeClasses()}>{this.formatCount()}</span>
        <button
          onClick={() => this.props.handleIncrement(this.props.id)}
          className="btn btn-secondary btn-sm"
        >
          Increment
        </button>
        <button
          className="btn btn-danger btn-sm m-2"
          onClick={() => {
            this.props.handleDelete(this.props.id);
          }}
        >
          Delete
        </button>
      </div>
    );
  }
}

export default Counter;
63.move handleIncrement from <Counter/> to <Counters/> and pass it down to <Counter/> via props:
handleIncrement = e => {
  //e is the event argument passed by the onClick of <Counter/> Increment button (id)
  // 1.copy state counters
  const counters = [...this.state.counters];
  // 2.find counter with clicked id and increment its value by 1
  counters.find(c => c.id === e).value++;
  // 3.set new counters object to state
  this.setState({ counters });
};

<Counter
  key={c.id}
  value={c.value}
  id={c.id}
  handleDelete={this.handleDelete}
  handleIncrement={this.handleIncrement}
/>
////// to simplify handleIncrement ///////
64.refactor <Counter/> in Counters.jsx to pass counter props instead of separate id and value:
{this.state.counters.map(c => (
  <Counter
    key={c.id}
    counter={c}
    handleDelete={this.handleDelete}
    handleIncrement={this.handleIncrement}
  />
))}
65.in Counter.jsx, change references to this.props.value and this.props.id to
this.props.counter.value and this.props.counter.id respectively:
formatCount() {
  const { value } = this.props.counter;
  return value === 0 ? "Zero" : value;
}

getBadgeClasses() {
  let classes = "badge m-2 badge-";
  classes += this.props.counter.value === 0 ? `warning` : `primary`;
  return classes;
}
...
<button
  className="btn btn-danger btn-sm m-2"
  onClick={() => {
    this.props.handleDelete(this.props.counter.id);
  }}
>
  Delete
</button>
66.in Counter.jsx Increment button, pass counter instead of id in handleIncrement => function:
<button
  onClick={() => this.props.handleIncrement(this.props.counter)}
  className="btn btn-secondary btn-sm"
>
  Increment
</button>
67.update simplified handleIncrement of <Counters/>:
handleIncrement = e => {
  //e is the event argument passed by the onClick of <Counter/> increment button (counter)
  // 1.copy state counters
  const counters = [...this.state.counters];
  // 2.increment value of counter by 1
  e.value++;
  // 3.set new counters object to state
  this.setState({ counters });
};